<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <title>window对象- BOM</title>
  <script type="text/javascript">
    /////////////////////////
    // BOM, 20140402, Wednesday, 15: 00
    // window 对象同时扮演着 ECMAScript 中和 Global对象 角色
    // 
    // frames:
    // top: 最高, 最外层的框架, 也就是浏览器窗口
    // window: 指向那个框架的特定实例
    // parent: 指向当前框架的上层
    // self: 与 window
    //
    // 窗口位置:
    //  IE, Opera, Safari support:
    // screenLeft: 浏览器窗口与屏幕左边距
    // screenTop: ...右..

    // Firefox support:
    // screenX: 浏览器窗口与屏幕左边距
    // screenY: ...右..
    // moveTo(), moveBy(): 将窗口移动到一个新置, 被浏览器禁用的

    // 窗口大小
    // innerWidth/innerHeight: browser 窗口本身大小
    // outerWidth/outerHeight: 页面视图区的大小(减去边框宽度)
    // Chrome以上4个都返回 视口(viewport)小,
    //   Support: ie9 +, firefox, safari, opera, hrome
    // document.documentElement.clientWidth/clientHeight: 保页面视口信息,
    // document.body.clientWidth/clientHeight: IE特有
    // IE在非标准模下, 必须通过; Chrome都可以 
    // 无法确定browser大小, 但可确定 viewport 小,
    // IE8更早通过DOM提供了页面可见区域的相关信息
    // resizeTo,
    // resizeBy: 调整浏览器窗口大小, 被禁用的, 只外层的window使用

    // 导航和打开窗口
    // open:
    // @加载URL, "http://www.baidu.com"
    // @窗口目标, "topFrame, _self, parent, _top, _blank"
    // @一个特性字符, (fullscreen, height, idht, left, top
    //   , location, menubar, resizable, scrollbars, status
    //   , toolbar)
    // @页面是否取代浏览器
    // close
    // closed
    // window.opener: 新建窗口中 保存着原始窗口象, 但原始窗口
    // 中并没有指针指向弹出窗口.
    
    // 系统对话框
    // alert: 向用户显示一条消息并等待用户关闭对话框
    // confirm: 显示一条消息, 要求用户单击"确定"或"消"
    // prompt: 显示一条消息, 等待用户输入字符串并返回那个字符串.
    //   window.print(); 显示打印对话框
    // window.find(); 显示查找对话框

    // location 对象
    // navigator 对象
    // screen 对象
    // history 对象

    /**
     * 全局与window差别:
     * 全局变量不能通过 delete 操作符删除, window 对象可以
     **/
    var age = 29;   //全局变量
    window.color = "red";   //windows变量
    delete window.age;     //在IE <9 时抛出错误
    delete window.color;    //return true
    (window.age);   // => 29
    (window.color);  // =>undefined
    // 访问未声明的变量会抛出错误
    // var newValue = oldValue;
    // 这里不会抛出错误,因为是一次属性查询,newValue的值是undefind
    var newValue = window.oldValue;

    /*********************
     * 8.1.2 窗口关系及框架
     * frames:
     *      top: 最外层的框架,也就是浏览器窗口
     *      window: 指向那个框架的特定实例
     *      parent: 指向当前框架的上层
     *      self : 与window
     * code: frameset1.htm
     **/

    /*********************
     * 8.1.3 窗口的位置
     * IE, Opera, Safari support:
     * screenLeft: 浏览器窗口与屏幕左边距
     * screenTop : ...右..
     *
     * Firefox support:
     * screenX :  浏览器窗口与屏幕左边距
     * screenY : ...右..
     *
     * moveTo(), moveBy(): 将窗口移动到一个新位置, 被浏览器禁用的
     */

    //跨浏览器获取窗口位置
    var leftPos = (typeof window.screenLeft == "number") ?
      window.screenLeft : window.screenX;
    var topPos = (typeof window.screenTop == "number") ?
      window.screenTop : window.screenY;
    ("Left: " + leftPos);
    ("Top: " + topPos);

    window.moveTo(0, 0);    // 将窗口称动到屏幕左上角
    window.moveBy(0, 100);  // 向下移动100像素

    /*********************
     * 8.1.4 窗口大小
     *
     * innerWidth, innerHeight : browser显示内容区域视图区大小(减去边框宽度)
     *
     * outerWidth, outerHeight : 浏览器大小
     *      在chrome以上4个都返回 视口( viewport )大小,
     *      Support: ie9+,firefox,safari,opera,chrome
     *
     * document.documentElement.clientWidth: 保存页面视口信息,
     *      Support: IE,Firefox,Safari,Opera,Chrome
     * document.documentElement.clientHeight:
     *
     * document.body.clientWidth, document.body.clientHeight :
     *      IE在 非 标准模式下,必须通过; Chrome都可以
     *
     * 无法确定browser大小, 但可确定 viewport 大小
     *
     * IE8更早通过DOM提供了页面可见区域的相关信息
     *
     * resizeTo(), resizeBy(): 调整浏览器窗口大小, 被禁用的, 只对外层的window使用
     *********************/

    //视口(viewport)大小获取, 窗口大小获取
    var pageWidth = window.innerWidth,
      pageHeight = window.innerHeight;

    if (typeof pageWidth != "number") {
      // 页面是否处于标准模式,chapter 10 discuss
      if (document.compatMode == "CSS1Compat") {
        console.log(1);
        pageWidth = document.documentElement.clientWidth;
        pageHeight = document.documentElement.clientHeight;
      }
      else { // IE 对于非标准模式(混杂模式),
        pageWidth = document.body.clientWidth;
        pageHeight = document.body.clientHeight;
        console.log(2);
      }
    }
    (pageWidth); // => 704
    (pageHeight); // => 415



    /**********************************
     * 8.1.5 导航和打开窗口
     * open() :
     *      @加载URL, "http://www.baidu.com"
     *      @窗口目标,"topFrame, _self, _parent, _top, _blank"
     *      @一个特性字符, fullscreen, height, widht, left, top, location, menubar,
     *          resizable, scrollbars, status, toolbar,
     *      @页面是否取代浏览器
     * resizeTo(500, 500):
     * moveTo(100, 100):
     * close():
     * closed
     * window.opener: 新建窗口中 保存着原始窗口对象, 但原始窗口中并没有指针指向
     *      弹出窗口,
     **/

    //window.open("http://www.baidu.com", "_blank",
    //                "height=400,width=400, top=100, left=10, resizable=yes");

    var wroxWin = window.open("http://www.baidu.com", "wroxWindow",
      "height=400,width=400, top=10, left=10, resizable=yes");
    if (wroxWin == null) {   //测试浏览器是否 开启屏蔽程序
      console.log("The popup was blocked!");
    }

    wroxWin.resizeTo(500, 500);
    wroxWin.moveTo(100, 100);
    wroxWin.close();    //top.close()只对open()的窗口有效;
    (wroxWin.closed);    //true, 窗口关闭后其引用还在;
    (wroxWin.opener == window);
    //切断 与上级 标签 面之间的联系, 在独立的进程中运行
    wroxWin.opener = null;

    /** 弹出窗口屏蔽程序
    **/
    var blocked = false;
    try {
      var wroxWin = window.open("http://www.baidu.com", "_blank");
      if (wroxWin == null) {
        blocked = true;
      }
    } catch (ex) {
      blocked = true;
    }
    if (blocked) {
      alert("The popup was blocked!");
    }
    wroxWin.close();


    /**********************************
     * 8.1.7 系统对话框
     *          alert():向用户显示一条消息并等待用户关闭对话框
     *          confirm():显示一条消息,要求用户单击"确定"或"取消"
     *          prompt():显示一条消息,等待用户输入字符串并返回那个字符串.
     ********************************/

    /*
    if(confirm("Are you sure?")){
        alert("I'm so glad you're sure!");
    }else{
        alert("I'm sorry to hear you're not srue. ");
    }
    */

    /*
    var result = prompt("what's your name?", "Michael");
    if (result !== null){
        alert("Welcom, " + result);
    }
    */

    /*
    do{
        var name = prompt("What is your name?");
        var correct = confirm("You entered '; " +name+ "' .\n"
                + "Click Okay to proceed or Cancel to re-enter.");
    }while(!correct)
    console.log("Hello" + name);    //输入一个纯文本的消息
    */

//window.print();   //显示打印对话框
//window.find();    //显示查找对话框

  </script>

</head>

<body>

  <!--  8.1.2 窗口关系及框架,
<frameset rows="160,*">
    <frame src="080/frame.htm" name="topFrame">
    <frameset cols="50%,50%">
        <frame src="080/anotherframe.htm" name="leftFrame">
        <frame src="080/yetanotherframe.htm" name="rightFrame">
    </frameset>
</frameset> -->

  <!--
权威指南 例14-1:使用showModalDialog()的HTML文件
这个HTML文件并不是独立的,这个文件由showModalDialog()所谓用
它希望window.dialogArguments是一个由字符串组成的数组
数组的第一个元素将放置在对话框的顶部
剩下的每个元素是每行的输入框的标识
当单击OKey按钮的时候,返回一个数组,这个数组是由每个输入框的值组成
使用诸如这样的代码来调用:
var p = showModalDialog("multiprompt.html",
    ["Enter 3D point coordinates", "x", "y", "z"],
    "dialogwidth:400; dialogheight:300; resizable:yes");


-->
  <form>
    <fieldset id="fields"></fieldset>
    <!-- Dialog body filled in by script below -->
    <div style="text-align:center">
      <!-- Buttons to dismiss the dialog -->
      <button onclick="okay()">Okay</button>
      <!-- Set return value and close -->
      <button onclick="cancel()">Cancel</button>
      <!-- Close with no return value -->
    </div>

    <script type="text/javascript ">

        /**
         * JavaScript权威指南
         * Chapter 14 window对象
         *  14.1 计时器
         *      setInterval()
         *  14.2 浏览器定位与导航
         *  14.3 浏览历史
         *  14.4 浏览器的屏幕信息
         *  14.5.对话框
         *  14.6 错误处理
         *  14.7 作为window对象
         *  14.8 多窗口和窗体
         *
         */

        /**
         * 权威指南 例14-1:使用showModalDialog()的HTML文件
         * Create the HTML for the dialog body and display it in the fieldset
         * 创建主体部份并在fieldset中显示出来
         */
    //               var args = dialogArguments;
                var args = [1, 2, 3]
                var text = "<legend>" + args[0] + "</legend>";
                for (var i = 1; i < args.length; i++)
                    text += "<label>" + args[i] + ": <input id='f" + i 
                    + "'></label><br>";
                document.getElementById("fields").innerHTML = text;
        
                // Close the dialog without setting a return value
                function cancel() {
                    window.close();
                }
        
                // Read the input field values and set a return value, then close
                function okay() {
                    window.returnValue = [];             // Return an array
                    // Set elements from input fields
                    for (var i = 1; i < args.length; i++) 
                        window.returnValue[i - 1] = document
                            .getElementById("f" + i).value;
                    // Close the dialog. This makes showModalDialog() return.
                    window.close();  
                }

        /**
         * 14.6 错误处理
         *
         */
        window.onerror = function (msg, url, line) {
                    if (onerror.num++ < onerror.max) {
                        alert("ERROR: " + msg + "\n" + url + ":" + line);
                        return true;
                    }
        }
        //        onerror.max = 3;
        //        onerror.num = 0;

        /**
         * 14.7 作为Window 对象属性的文档元素
         */
        var ui = ["input","prompt","heading"]; //数组中存放要查找的元素id
        ui.forEach(function(id){    // 用每个id查找对应的元素
            ui[id] = document.getElementById(id);//将其存放在一个属性中
        });

        var $ = function(id){ return document.getElementById(id);}




/*********************************************************
 *  Chapter 8: BOM, 20140404, Friday, 10:02
 *  8.1 window对象
 *  8.2 location 对象
 *          location: 即是window, 也是document的属性
 *              hash: "#contents",URL中片段标识符部份
 *              host: "www.baidu.com:80,
 *              hostname: "www.baidu.com",
 *              href:"http://www.baidu.com",
 *              pathname: "/WileyCDA/", 返回URL中的目录或文件名
 *              port: "8080,
 *              protocol:  http:,
 *              search : "?q=javascript"
 *
 *              assign(): 载入并显示你指定的URL中的文档
 *              replace(): 载入
 *              reload(true): 载入
 *  8.3 navigator 对象, (浏览器的屏信息)
 *      appName:browser全称,
 *      appVersion:浏览器厂商版本信息
 *      userAgent:浏览器在它的USER-AGENT HTTP头部中发送的字符串
 *      platform:在其上运行浏览器的操作系统
 *      plugins: 插件
 *  8.4 screen 对象
 *  8.5 history 对象
 ********************************************************/

/**
 * Document 对象的loaction属性也引用到Location对象
 */
(window.location === document.location); // => true

/**
 * href属性是一个字符串,后者包含URL的完美文本,Location对象的toString()方法
 * 返回href属性的值,因此在会隐式调用toString()的情况下,可以使用Location代
 * 替location.href
 */
(location == location.href);   // => true

/***
 * 8.2.1 查找字符串参数
 * assume query string of ?q=javascript&num=10
 */
function getQueryStringArgs() {
    //get query string without the initial ?
    var qs = (location.search.length > 0 
            ? location.search.substring(1) : ""),
                args = {},      //object to hold data
                //get individual items
                items = qs.length ? qs.split("&") : [],
                item = null,
                name = null,
                value = null,
                i = 0,  //used in for loop
                len = items.length;

            //assign each item onto the args object
            for (i = 0; i < len; i++) {    
                item = items[i].split("=");
                name = decodeURIComponent(item[0]);
                value = decodeURIComponent(item[1]);
                if (name.length) {
                    args[name] = value;
                }
            }
            return args;
}

var args = getQueryStringArgs();
(args["q"]);     // => "javascript"
(args["num"]);   // => "10"



/* 权威指南 14-2:提取URL的搜索字符串中的参数
 * This function parses ampersand-separated name=value argument pairs from
 * the query string of the URL. It stores the name=value pairs in
 * properties of an object and returns that object. Use it like this:
 *
 * var args = urlArgs();  // Parse args from URL
 * var q = args.q || "";  // Use argument, if defined, or a default value
 * var n = args.n ? parseInt(args.n) : 10;
 */
function urlArgs() {
    var args = {};                             // Start with an empty object
    var query = location.search.substring(1);  // Get query string, minus '?'
    var pairs = query.split("&");              // Split at ampersands
    for (var i = 0; i < pairs.length; i++) {    // For each fragment
        var pos = pairs[i].indexOf('=');       // Look for "name=value"
        if (pos == -1) continue;               // If not found, skip it
        var name = pairs[i].substring(0, pos);  // Extract the name
        var value = pairs[i].substring(pos + 1); // Extract the value
        value = decodeURIComponent(value);     // Decode the value
        args[name] = value;                    // Store as a property
    }
    return args;                               // Return the parsed arguments
}
var args2 = urlArgs();
(args2["q"]);   // => "javascript"

/***
 * 8.2.2 位置操作
 * assign():载入并显示你指定的URL中的文档
 */
//location.assign("http://www.baidu.com");    //历史记录中生成一条记录
//window.location = "http://www.baidu.com";   //更传统的方式
//location.href = "http://www.baidu.com";
//location = "#top";    //跳到文档的顶部

/**
 * 通过将 hash, search, hostname, pathname, port 属性设置为新值改变URL
 * 假设初值URL为http://www.wrox.com/WileyCDA/
 */
//将URL修改为"http://www.wrox.com/WileyCDA/#section1"
//location.hash = "#section1";
//location.search = "?q=javascript"; // 加上 http://...//WileyCDA/?q=javascript
//location.hostname = "www.yahoo.com"; // http://www.yahoo.com//WileyCDA/
//location.pathname = "mydir"; // http://www.yahoo.com/mydir
//location.port = 8080;

/**当调用跳转后, 在浏览器单击后退,会返回
 *  replacle() :载入,比assgin()更好的选择."后退"
 *  reload(): 重新加载
 */
            //location.replace("http://www.baidu.com");

//        location.reload();      //重新加载(有可能从缓存中加载)
//        location.reload(true); //重新加载(从服务器加载)

/*************************************
 * 8.3 navigator 对象
 *      浏览器的屏信息
 *      识别客户端浏览器的事实标准, navigator对象是所有支持JavaScript浏览器
 *          所共有的
 *      属性:
 *      appName:browser全称,
 *      appVersion: 浏览器厂商版本信息
 *      userAgent: 浏览器在它的USER-AGENT HTTP头部中发送的字符串
 *      platform: 在其上运行浏览器的操作系统
 *      onLine: 表示当前浏览器当前是否连接到网络
 *      geolocation: Geolocation对象定义用于确定用户地理位置信息的接口.
 *      javaEnabled(): 一个非标准的方法,当浏览器可以运行java小程序时返回true
 *      cookieEnable(): 非标准方法,如果浏览器可以保存永久的cookie时,返回true.
 */
(navigator.appName);    // => Netscape
(navigator.appVersion); // => 5.0 (window NT ...
(navigator.userAgent.toLowerCase()); // => mozilla/5.0 ...
(navigator.platform);   // => Win32

/**
 * 例14-3: 使用navigator.userAgent来进行浏览器嗅探
 * Define browser.name and browser.version for client sniffing, using code
 * derived from jQuery 1.4.1. Both the name and number are strings, and both
 * may differ from the public browser name and version. Detected names are:
 *
 *   "webkit": Safari or Chrome; version is WebKit build number
 *   "opera": the Opera browser; version is the public version number
 *   "mozilla": Firefox or other gecko-based browsers; version is Gecko version
 *   "msie": IE; version is public version number
 *
 * Firefox 3.6, for example, returns: { name: "mozilla", version: "1.9.2" }.
 */
var browser = (function() {
    var s = navigator.userAgent.toLowerCase();
    var match = /(webkit)[ \/]([\w.]+)/.exec(s) ||
            /(opera)(?:.*version)?[ \/]([\w.]+)/.exec(s) ||
            /(msie) ([\w.]+)/.exec(s) ||
            !/compatible/.test(s) && /(mozilla)(?:.*? rv:([\w.]+))?/.exec(s) ||
            [];
    return { name: match[1] || "", version: match[2] || "0" };
}());
//for(var p in browser) console.log(p +" : "+browser[p]);


/**
 *  8.3.1 检测插件
 *  对于非IE浏览器, 可用plugins 数组来达到这个目的, plugins 包含以下属性:
 *  name, description, filename, length
 */
function hasPlugin(name) {
    name = name.toLowerCase();
    for (var i = 0; i < navigator.plugins.length; i++) {
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) > -1) {
            return true;
        }
    }
    return false;
}
(hasPlugin("Flash"));        // => true, 检测Flash
(hasPlugin("QuickTime"));    // => false, 检测QuickTime

/**
 *  检测IE中的插件
 *  IE不支持Netscape式的插件, 唯一的方式是用专有的 ActiveXObject类型,
 *  IE是以COM对象的方式实现插件的, 而COM对象使用唯一标识符来标识, 
 *  so要检测特定的插件, 就必须知道其COM标识符,
 *  例如Flash的标识符是ShockwaveFlash.ShockwaveFlash
 */
        function hasIEPlugin(name){
            try {
                new ActiveXObject(name);
                return true;
            } catch (ex){
                return false;
            }
        }
(hasIEPlugin("ShockwaveFlash.ShockwaveFlash"));//detect flash
(hasIEPlugin("QuickTime.QuickTime")); //detect quicktime

/*
 * 两种方法差别较大, so 针对每个插件分别创建检测函数,
 */
       function hasPlugin(name) {
            name = name.toLowerCase();
            for (var i = 0; i < navigator.plugins.length; i++) {
                if (navigator.plugins[i].name.toLowerCase().indexOf(name) > -1) {
                    return true;
                }
            }
            return false;
        }
        function hasIEPlugin(name) {      //plugin detection for IE
            try {
                new ActiveXObject(name);
                return true;
            } catch (ex) {
                return false;
            }
        }
        function hasFlash() {   //detect flash for all browsers
            var result = hasPlugin("Flash");
            if (!result) {
                result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash");
            }
            return result;
        }
        function hasQuickTime() {   //detect quicktime for all browsers
            var result = hasPlugin("QuickTime");
            if (!result) {
                result = hasIEPlugin("QuickTime.QuickTime");
            }
            return result;
        }
    (hasFlash()); // detect flash
    (hasQuickTime()); // detect quicktime

    /** 8.3.2 注册处理程序
     * 8.4 screen 对象
     *      secreen 属性引用是Screen对象.它提供有关窗口显示大小和可用的颜色数量
     * 8.5 history 对象
     *      history是window对象属性, 
     *          因此每个浏览器窗口,每个标签都有自己的history
     */
    //        history.go(-2);   //后退2次
    //        history.go(1);    //前进一页
    //        history.go(2);      //前进两页
    //        history.go("baidu.com");    //跳到最近的baidu.com页面

    //        history.back();     //后退一页
    //        history.forward();  //前进一页
        


    /** 16.4 历史状态管理
     *      hashchange 事件: URL的参数什么时候发生了变化
     *      history.pushState( 状态对象, 新状态的标题, 相对URL ) :
     *      replaceState()
     */
      //  history.pushState({name: "Nicholas"}, "Nicholas' page", "nicholas.html");

    

</script>
  </form>


</body>

</html>