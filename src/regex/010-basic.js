/************************************
 * Chapter 1 正则表达式入门
 *
 * 正则表达式：regular expression
 * 
 * 两种字符构成：
 *      1.特殊字符(special characters)称为=> 元字符(metacharacters)
 *      2.其它为文字(literal)
 *
 * ^: 起始 或 \<
 * $: 结束 或 \>
 *
 *
 * 字符组：
 *  [ea]
 *  sep[ea]r[ea]te: e或a
 *  
 *
 * 字符组元字符(charater-class metacharacter):
 *  -: 连字符 => [H1-6], [0-9] 需在字符组内部且不是第1位才成立
 *  ^: 取反=> q[^u] =>q后没有u,
 *
 * 
 *  .: 元字符=> 匹配任意字符的占位符(placeholder), 字符组外部才行
 *      /03[-./]19[-./]76/  = /03.19.76/, 
 *      在[-./]中的点号不是元字符，在字符组内定义不一样。
 *      -: 也不是连字符，因为它们都紧接在 [ 或者 ^ 之后。
 *        如果是 [.-/] 可表示连字符
 *
 *  |: 或=> 多选分支 (alternative) => /grey|gray/, /gr(a|e)y/
 *      /gr[a|e]y/ 这里的"|"与普通字符一样
 *
 **/

// Same
/Jeffrey|Jeffery/;
/Jeff(rey|ery)/;
/Jeff(re|er)y/;


/***************************************
 *  可选项元素
 *  ? : 可选项，0次或1次， 
 *  + : 1次或多次
 *  * : 0次或多次
 * 
 *
 * 规定重现次数的范围： 区间
 * [a-zA-Z]{1,5} : 1到5个字母
 * ? = {0, 1}
 *
 *
 * 括号及反向引用
 *
 **/


var str = "test text";
/([a-z])([0-9])/.test(str);


// HTTP/HTML URL
// /\http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?/;

//时间 9:17 am 或者 12:30 pm
/(1[012]|[1-9]):[0-5][0-9](am|pm)/;

//24小时制
/0?[0-9]|1[0-9]|2[0-3]:/;




/****************************
 * 正则表达式述语
 * regex: 正则
 * matching: 匹配
 * metacharacter: 元字符
 *      metasequence: 元字符序列
 *      escaped: 转义
 * flavor: 流派
 * subexpression: 子表达式
 * character: 字符
 *
 * In perl: 
 *
 **/

//区配正负 华摄氏度
/[-+]?[0-9]+[CF]/;

// 接收 98.6f 输入
/([-+]?[0-9]+(\.[0-9]*)?)([CF])/;
// 用 (\.[0-9]*)? 这样做副作用是括号内的子表达式捕获
// 的文本保存到$2中。而我们并不会使用$2

// 不捕获
// (?:)
// (...): 用来分组和捕获而 (?: ...): 只分组不捕获
// 这里的 ? 和可选项的 ? 元字符没有任何联系
/([-+]?[0-9]+ (?:\.[0-9])?)([CF])$/;
// 这样做好处有2点:
// 1.避免不必要的捕获，提高了匹配效率
// 2.跟据选择合适的括号能够让程序更清晰

//用 \s匹配所有空白
/([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i;
//matching "CFcf"


//////////////////////////////
// 环视(lookaround)
// 环视功能为数值添加逗号
// print "The US population is 298444215"
// 环视只匹配文本中的特定位置
// 
// 肯定顺序环视 lookahead
// 肯定型顺序环视 positive lookahread 
// (?=)
// (?=\d)如果当前位置右边的字符是数字则匹配成功
//
// 肯定逆序环视 (从右向左) 
// (?<=)
// JavaScript 中不支持
// (?=<\d): 如果当前位置的左边有一位数字则匹配成功
//
// 否定顺序环视
// (?!)
//
// 否定逆序环视
// (?<!)

var str_2 = "by Jeffrey Friedl",
    reg_2 = /(?=Jeffrey)/;

(/(?=Jeffrey)/.test(str_2));// true
/(?=Jeffrey)Jeff/.test(str_2); // true
/Jeff(?=Jeffrey)/.test(str_2); // false
/(?=Jeffrey)Jeff/ == /Jeff(?=rey)/; //等价的

/***********************
 * /g: 全体替换
 * Jeff 替换为 Jeff's 几种办法
 * */
/Jeffs\/Jeff's/;
/\bJeffs\b\/Jeff's/g;   //加入单词分界符
/\b(Jeffs)(s)\b\/$1'$2/g;  //更复杂的方式

/\bJeff(?=s\b)\/Jeff'/g; //顺序环视
// /(?<=\bJeff)(?=s\b)\/'/g;   //逆序环视
// /(?=s\b)(?<=\bJeff)\/'/g;

// 两者结合 combanation of the two
// 左右两边都要匹配成功


// 匹配逗号 需满足 左边有数字，右边数字是3的倍数
// /(?<=\d)/; // 左边有数字
/(?=(\d\d\d)+$)/;   // 右边
// $: 以三位数字结尾

// /(?<=\d)(?=(\d\d\d)+$)\/./g;    //这里的 \d\d\d 在捕获 $1中
// /(?<=\d)(?=(?:\d\d\d)+$)\/./g;  //非捕获

//用 (?!\d) 来标记3位数字取代 \b 或 $
// /(?<=\d)(?=(\d\d\d)+(?!\d))\/,/g;

//不使用逆序环视
/(\d)(?=(\d\d\d)+(?!\d)) \/ $/g;

//错误的表达式
/(\d)((\d\d\d)+\b)\/$1,$2/g;
//会配置 281,421906

$text = '281421906';
while( a = /(\d)((\d\d\d)+\b)/.exec(text) ) {
    console.dir(a);
}

/************************
 * 匹配用户名和主机名
 * page 100
 ****/
/[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)/;


// $text =~ s/&/&amp;/g;   
// s: 忽略换行元









