<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Chapter13 Web浏览器中的javascript</title>
</head>
<!--
JavaScript 权威指南
Chapter13 Web浏览器中的javascript
13.2.5 URL中的JavaScript
-->
<a href="javascript:new Date().toLocaleTimeString();">What time is it?</a><br>
<a href="javascript:alert(new Date().toLocaleTimeString());">
    检查时间,而不必覆盖整个文档
</a><br>
<a href="" onclick="alert(new Date().toLocaleDateString())">
    onclick显示时间
</a><br>
<a href="javascript:void window.open('about:blank');">打开一个窗口</a><br>
书签:打开一个简单的JavaScript表达式计算器,它允许在页面环境中计算和执行
<a href='javascript:
var e = "", r = "";  /* 需要计算的表达式和结果 */
do{
    /* 输出表达式结果,并要求输入新的表达式 */
    e = prompt("Expression: " +e+ "\n" + r + "\n", e);
    try{ r = "Result: " + eval(e);}/*尝试计算这个表达式*/
    catch(ex){r = ex;}          /*否则记住这个错误*/
}while(e);/*直到没有输入表达式或者单击了Cancel按钮才会停止,否则一直循环执行*/
void 0; /*这句代码用以防止当前文档被覆盖*/
'>JavaScript Evaluator</a>

<!--
-->
13.3.1 同步,异步和延迟的脚本
例13-3: 载入时生成文档内容

<h1>Table of Factorials</h1>
<script type="text/javascript">
    function factorial(n){      //用来计算阶乖的函数
        if( n <= 1)return n;
        else return n*factorial(n-1);
    }
    document.write("<table>");  //开如创建HTML表
    document.write("<tr><th>n</th><th>n!</th></tr>");   //输出表头
    for(var i = 1; i <= 10; i++){   //输出10行
        document.write("<tr><td>"+ i +"</td><td>"+ factorial(i) +"</td></tr>");
    }
    document.write("</table>"); //表格结束
    document.write("Generated at " + new Date());   //输出时间
</script>


<!--
defer和sync属性都像在告诉浏览器链接进来的脚本不会使用document.write().
也不会生成文档内容,
defer: 使浏览器延迟脚本的执行,直到文档的载入和解析完成,并可以操作.
async: 属性使得浏览器可以尽快地执行脚本,而不用在下载脚本时阻塞文档解析
如果时使用这两个属性,会遵从async属性并忽略defer属性

<script type="text/javascript" defer src="deferred.js"></script>
<script type="text/javascript" async src="async.js"></script>
-->

<hr>
<!--
async和defer属性还没有广泛实现,它们只被一些优化建议所考虑.
通过<\Script>元素并把它插入到文档中,来实现脚本的异步载入和执行,
-->
<script type="text/javascript">
    // Asynchronously load and execute a script from a specified URL
    function loadasync(url) {
        // Find document <head>
        var head = document.getElementsByTagName("head")[0]; 
        var s = document.createElement("script");  // Create a <script> element
        s.src = url;                               // Set its src attribute
        head.appendChild(s);               // Insert the <script> into head
    }
</script>


<script type="text/javascript">
    /**
     * 13.3.2 事件驱动的JavaScript
     *  如果想要程序响应一个事件,写一个函数,叫做"事件处理程序","事件监听器"
     *  或"回调".然后注册这个函数,这样地就会在事件发生时调用它.
     */
    //    window.onload = function(){};
    //    document.getElementById("buttion1").onclick = function(){};
    //    function handleResponse(){}
    //    request.onreadystatechange = handleResponse;

    /**
     * 例13-5: onLoad(),当文档载入完成时调用一个函数
     * Register the function f to run when the document finishes loading.
     * 注册函数f,当文档载入完成时执行这个函数f
     * If the document has already loaded, run it asynchronously ASAP.
     * 如果文档已经载入完成,尽快以异步方式执行它
     */
function onLoad(f) {
    if (onLoad.loaded)           // If document is already loaded
        window.setTimeout(f, 0); // Queue f to be run as soon as possible
    else if (window.addEventListener)// Standard event registration method
        window.addEventListener("load", f, false);
    else if (window.attachEvent)        // IE8 and earlier use this instead
        window.attachEvent("onload", f);
}
// Start by setting a flag that indicates that the document is not loaded yet.
onLoad.loaded = false;
// And register a function to set the flag when the document does load.
onLoad(function () {
    onLoad.loaded = true;
});

    /**
     * 13.3.3 客户端JavaScript线程模型
     * 13.3.4 客户端JavaScript时间线
     * 13.4 兼容性和互用性
     *      https://developer.mozilla.org    Mozilla开发中心
     *      http://msdn.microsoft.com       Microsoft开发者网络
     *      http://developer.apple.com/safari Apple开发者网络里的Safari开发者中心
     *      http://code.google.com/doctype Google Doctype:"开放Web的一本百科全书"
     *      http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(HTML5) :
     *      Wikipedia文章跟踪了HTML5特性和API在各个浏览器里的实现状态
     *      http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Document_Object_Model) :
     *      一篇简单的文章,跟踪DOM特性的实现状态
     *      http://a.deveria.com/caniuse    跟踪重要Web特性的实现状态,允许根
     *          据各种标准进行过滤
     *      http://www.quirksmode.org/dom   跟据W3C标准列出的各种浏览器的DOM
     *          兼容表格
     *      http://webdevout.net/browser-support  跟踪浏览器开发商对于Web标
     *          准的实现的站点
     *
     *  13.4.1 处理兼容性问题的类库
     *      jquery
     *  13.4.2 分级浏览器的支持  (graded browser support)
     *  13.4.3 功能测试(capability testing)
     */
 /*
        if(element.addEventListener){
            element.addEventListener("keydown", handler, false);
            element.addEventListener("keyPress", handler, false);
        }
        else if (element.attachEvent){
            element.attachEvent("onkeydown", handler);
            element.attachEvent("onkeypress", handler);
        }
        else{
            element.onkeydown = element.onkeypress = handler;
        }
 */

    /**
     * 13.4.4 怪异模式和标准模式
     * 13.4.6 Internet Explorer 里的条件注释
     */

    //只有在IE中才会被执行
    /* @cc_on
     @if (@_jscript)
     alert(In IE); //该代码位于一条JS注释内但在IE中执行它
     @end
     @ */

    /**
     * 13.5 可访问性
     * 13.6 安全性
     *  13.6.1 JavaScript 不能做什么
     *      1.可打开一个窗口
     *      2.可关窗窗口
     *      3.HTML FileUpload 元素的value属性是只读的. 如果可以设置这个属性,脚本
     *      就能设置它为任意期望的文件名.
     *      4.脚本不能读取从不同服务器载入的文档的内容
     */
 </script>


<!--[if IE]>
<script src="lib/090_client.js"></script>
<![endif]-->





<script type="text/javascript">
    /**
     * 13.6.4 跨站脚本
     */
// var name = decodeURIComponent(window.location.search.substring(1) || "");
// document.write("<br> Hello " + name);

    /**
     * 防止XSS攻击的方式是,在使用任何不可信的数据来动态的创建文档内容之前
     * ,从中移除HTML标签,可以通过添加如下一行代码移除<\script>标签两边的尖
     * 括号,从而修复前面给出的greet.html文件
     */
    name = name.replace(/</g, "%lt;").replace(/>/g, "&gt;");

    /**
     * 13.7 客户端框架
     *      Prototype: 专门针对DOM和Ajax实现的一套实用工具,
     *      Dojo: 大型的框架,包含一个种类繁多的UI组件集合,管理系统,数据抽象层等
     *      YUI: 与Dojo一样强大,无所不包的类库,
     *      Closure : http://developers.google.com/closure/library/ 是Google应用
     *      Gmail,Google Docs和其他Web应用的客户端类库,这个类库是打算和Closure编
     *      译器配合使用的.
     *      GWT: http://developers.google.com/webtoolkit/,即Google Web Toolkit
     *      是一个完全不同类型的客户端框架,它用JAVA定义了Web应用接口,并提供编译器,
     *      将JAVA程序翻译成兼容的客户端JavaScript.GWT在一些Google产品中使用,但是
     *      不如它们自己的Closure类库用的广泛.
     */

</script>
<body>

</body>
</html>
